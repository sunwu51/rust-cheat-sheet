/// 生命周期是每个变量存在的时间范围，一般来说变量的生命周期就是他所在的scope结束
/// 一般来说如果我们要给结构体一个name属性，我们会使用String，而不是&str防止后者命短，导致结构体.name找不到正确的值。
/// 一般来说我们可以用引用作为函数入参，但不作为返回值，因为可能出现栈内存逃逸，导致指针指向错误数据。
/// 但是引用类型有时候非常有用，我们不妨给类型添加生命周期约束。比如上面结构体例子我们给name设置生命周期约束，
/// struct User<'a> {name: &'a str}
/// User<'a>表示结构体的生命周期是a， &'a str表示这个引用至少比a命长。

struct User<'a> {
    name: &'a str,
}
// 接下来我们只能给name传一些，能保证比struct命长的&str.

fn main() {
    // 字面量Tom是存到代码区的，生命周期是'static也就是无限长，所以肯定活过a了
    let u = User{name: "Tom"};
}
/// 正常情况下直接返回一个引用类型&String会报错，提示引用类型得加生命周期约束才能作为返回类型
/// fn f() -> &str {
///     &"123"
/// }
/// 加了生命周期约束的引用才能作为返回类型
fn f() -> &'static str {
    "123"
}

/// 自定义生命周期约束'a，表示入参s1的生命周期，和返回值生命周期一致
/// 即返回值至少活的和入参s1一样长
fn f2<'a>(s1: &'a str, s2: &str) -> &'a str {
    s1
}

/// 语法糖：当只有一个引用参数时，可以不写生命周期约束，等价于有个'a
fn f3(s1: &str, s2: i32) -> &str {
    s1
}
// f3是f4的语法糖
fn f4<'a>(s1: &'a str, s2: i32) -> &'a str {
    s1
}

/// 高级用法1，'a与泛型一起出现，'a在前面
fn f5<'a, T> (s1: &'a str, s2: T) -> &'a str {
    s1
}

/// 高级用法2，给泛型T添加生命周期约束，注意前面都是&'a在引用后面加的
///     表示T类型得比s1数据活的长，注意&'a表示该引用指向的数据生命周期是a，而T:'a是说类型T至少活过a
fn f6<'a, T>(s1: &'a str, s2: T) -> &'a str
where T: 'a{
    s1
}

/// 高级用法3，给另一个生命周期b添加'a约束
fn f7<'a, 'b, T>(s1: &'a str, s2: &'b T) -> &'a str
where T: 'a, 'b:'a{
    s1
}

// 生命周期约束和引用生命周期是两种位置两种用法，记得区分清楚。
// 尝试理解下面几处'a的作用
fn f8<'a, T, N>(s1:T, s2:N, s3: &'a T) -> &'a str
where T: 'a, N: 'a{
    "123"
}

// 我们可以这样理解生命周期，他就像一道数学题
// 现在给定一个变量'a代表一段生命周期区间，现在给函数f8两个入参假如就是1,true,&10.
// T、N类型确定下来，此时需要寻找是否存在这样一个'a满足
// 1 life(s1) >= 'a
// 2 life(s2) >= 'a
// 3 life(s3) >= 'a
// 4 life("123") = 'static >= 'a
// 答案是存在，只需'a = s1的生命周期即可满足上述条件（假设入参1，true, &10是同样的生命周期）
//  于是编译通过。

fn f9() {
    f8("123", true, &"123");
}